rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is an editor of a graduation
    function isEditor(graduationId) {
      let gradData = get(/databases/$(database)/documents/graduations/$(graduationId)).data;
      return request.auth != null && 
             (request.auth.uid in gradData.editors ||
              (gradData.ownerUid != null && request.auth.uid == gradData.ownerUid));
    }
    
    // Graduation documents
    match /graduations/{gradId} {
      // Allow read if user is an editor (with backwards compatibility for ownerUid)
      allow read: if request.auth != null && 
                     (request.auth.uid in resource.data.editors ||
                      (resource.data.ownerUid != null && request.auth.uid == resource.data.ownerUid));
      
      // Allow create if authenticated (user will be added to editors array)
      allow create: if request.auth != null &&
                       request.auth.uid in request.resource.data.editors &&
                       request.resource.data.editors.size() >= 1;
      
      // Allow update if user is an editor (with backwards compatibility for ownerUid)
      // Special rules for editors array modification and presence tracking
      allow update: if request.auth != null && 
                       (request.auth.uid in resource.data.editors ||
                        (resource.data.ownerUid != null && request.auth.uid == resource.data.ownerUid)) &&
                       // For new projects with editors array, ensure at least one editor
                       (resource.data.editors == null || request.resource.data.editors.size() >= 1) &&
                       // Only existing editors can modify the editors array (if it exists)
                       (resource.data.editors == null || 
                        request.resource.data.editors == resource.data.editors ||
                        request.auth.uid in resource.data.editors) &&
                       // Prevent modification of createdBy field (immutable)
                       (!request.resource.data.keys().hasAny(['createdBy']) ||
                        request.resource.data.createdBy == resource.data.createdBy);
      
      // Allow presence tracking updates (activeEditors map) without full editor permissions
      // This allows editors to update their own presence timestamp
      allow update: if request.auth != null && 
                       (request.auth.uid in resource.data.editors ||
                        (resource.data.ownerUid != null && request.auth.uid == resource.data.ownerUid)) &&
                       // Only allow updates to activeEditors field
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['activeEditors', 'updatedAt']);
      
      // Allow delete if user is an editor (with backwards compatibility for ownerUid)
      allow delete: if request.auth != null && 
                       (request.auth.uid in resource.data.editors ||
                        (resource.data.ownerUid != null && request.auth.uid == resource.data.ownerUid));
      
      // Students subcollection
      match /students/{studentId} {
        // Allow read/write if user is an editor of the parent graduation
        allow read, write: if isEditor(gradId);
      }
      
      // Content pages subcollection
      match /contentPages/{pageId} {
        // Allow read/write if user is an editor of the parent graduation
        allow read, write: if isEditor(gradId);
      }
    }
    
    // Public read access for specific routes (like student upload portals)
    // These are handled separately by the application logic
  }
}
